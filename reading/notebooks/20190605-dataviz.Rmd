---
title: "**Workshop**"
author: "Dr Lauren M Ackerman"
date: "05 JUN 2019"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float: 
      smooth_scroll: true
      collapsed: false
    theme: sandstone
    highlight: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


# 1. R and RStudio interfaces, RMarkdown, and best practices
#    - Basic functionality, shortcuts, writing scripts and notebooks, organising files, interfacing with GitHub
# 2. Data frame manipulation using Tidyverse
#    - Piping syntax and code replicability
#    - Tidyr, Dplyr, related packages
#    - Cleaning, combining, and rearranging data frames
# 3. Data visualisation using ggplot and best practices
#    - Structure and syntax of ggplot and geom
#    - Customising and combining plots
#    - Determining what plot is best for your data
# 4. Basic linear models without and with mixed effects (including gaussian, binomial, and ordinal)
#    - building/selecting an appropriate model, including random effect structures
#    - maximal vs parsimonious models
#    - practical use of lm(), lmer(), glm(), glmer(), clmm()
#    - dummy coding vs contrast coding
#    - interpreting the output
```
[⇠ Day 2](20190604-tidyverse.html) || [Day 4 ⇢](20190606-stats.html)

Download course materials (.zip file) from [here](http://bit.ly/RforLinguists-201906) *after 2nd June*.

[**bit.ly/RforLinguists-201906**](http://bit.ly/RforLinguists-201906)

You will need these datasets today:

1. [binomial-data.csv](ExampleProject/data/binomial-data.csv)

You may also need to install the package `ggbeeswarm`:
```{r}
install.packages("ggbeeswarm")
```

Load in today's libraries.
```{r}
# https://bookdown.org/ndphillips/YaRrr/pirateplot.html
library(tidyverse)
library(ggbeeswarm)
```

# Plotting in base R

I think it's good to know how to do it, but for most purposes, `ggplot2` will be easier and more powerful.

## Scatter plots

Plot the geocoordinates of `quakes`:
```{r}
plot(quakes$lat ~ quakes$long)
```

Change the colour and point character (pch):
```{r}
plot(quakes$lat ~ quakes$long, 
     col="red", 
     pch=3)
```

Change colour by longitude:
```{r}
plot(quakes$lat[quakes$long>175] ~ quakes$long[quakes$long>175], 
     col="red", 
     pch=3, 
     xlim=c(160,190), 
     ylim=c(-40,-10))
points(quakes$lat[quakes$long<=175] ~ quakes$long[quakes$long<=175], 
       col="blue", 
       pch=4)
```

Change axis labels and add a vertical line to show the split:
```{r}
plot(quakes$lat[quakes$long>175] ~ quakes$long[quakes$long>175], 
     col="red", 
     pch=3, 
     xlim=c(160,190), 
     ylim=c(-40,-10),
     xlab="longitude",
     ylab="latitude",
     main="`quakes` dataset")
points(quakes$lat[quakes$long<=175] ~ quakes$long[quakes$long<=175], 
       col="blue", 
       pch=4)
abline(v=175,col="green4",lty="dashed")
```

## Box plots

Here we can visualise the distribution of `sleep` results for groups 1 and 2. We can use the same extra parameters as before to clean it up, too.
```{r}
boxplot(sleep$extra ~ sleep$group, 
        col=c("red","blue"),
        xlab="group",
        ylab="extra hours of sleep",
        main="`sleep` dataset")
```

We can add the parameter `notch` to indicate where the bulk of the data are located, and are intended to give a visual estimate if the distributions overlap little enough to estimate that they are distinct populations.
```{r}
boxplot(sleep$extra ~ sleep$group, 
        col=c("red","blue"),
        xlab="group",
        ylab="extra hours of sleep",
        main="`sleep` dataset",
        notch=TRUE)
```

But how many data points go into these graphs? Not enough to prevent "hinges" from being larger than the actual interquartile ranges. And where *are* the points?

```{r}
boxplot(sleep$extra ~ sleep$group, 
        col=c("red","blue"),
        xlab="group",
        ylab="extra hours of sleep",
        main="`sleep` dataset",
        notch=TRUE)
points(sleep$extra ~ sleep$group)
```

So we get a decent view of how these groups are distributed, but we can do better.

## When to use base R graphics

The only times I personally use base R to plot things now is when I only want to take a very quick peek at a scatter plot or if I want to use one of the built-in visualisations of regressions (e.g., `qqplot`, which you should now be able to explore on your own!)

# Components of a ggplot

We build up plots in `ggplot2` starting with a base and slowly adding different geometries and properties, using a similar logic to how we added the annotation line to a scatterplot in base R. However, `ggplot` gives us a much more powerful interface because it allows us to do calculations during plotting and remember certain parameters *between* different layers of the plot.

## Base plot

The base plot by itself doesn't look like much, but it already shows us that there's a lot going on.
```{r}
ggplot(data=quakes,aes(x=long,y=lat))
```

Plus it just looks sleeker. (And don't underestimate the power of pleasant-looking graphics!)

One of the parameters of the base plot is `aes()`, which stands for "aesthetics". Aesthetics of the base plot are the attributes of the plot that should be inherited for all layers. This typically includes things like the x-axis, y-axis, any colour-coding by groups, etc. We'll come back to this in a few minutes.

## Geometries

In order to actually see our data, we have to tell R what kind of plot we want to make. Let's start with a scatterplot, i.e., points.
```{r}
ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_point()
```

Notice how we didn't have to specify anything within the parameters for `geom_point()`. This is because everything that it requires has been inherited from the base plot. We could also use different geometries.

`geom_hex` can clearly demonstrate how ggplot does "calculations" during plotting:
```{r}
ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_hex()

ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_bin2d()

ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_count()

ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_density2d()
```

We can try a few others out, but these plots aren't really designed to be informative for these kinds of data.
```{r}
ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_area()

ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_col()

ggplot(data=quakes,aes(x=long,y=lat)) +
  geom_path()
```

Some plots don't need y aesthetics because they calculate y based on frequency in the input:
```{r}
ggplot(data=quakes,aes(x=long)) +
  geom_density()

ggplot(data=quakes,aes(x=long)) +
  geom_freqpoly()

ggplot(data=quakes,aes(x=long)) +
  geom_histogram()
```

And some plots need (at least) one axis to not be continuous data, like `boxplot`.
```{r}
ggplot(data=quakes,aes(x=as.factor(mag),y=stations)) +
  geom_boxplot()

ggplot(sleep, aes(x=group,y=extra)) +
  geom_boxplot()
```

### Refresher

How would you use piping to plot only one island's worth of data?
```{r}
quakes %>% 
  filter(long>175) %>% 
  ggplot(aes(x=long,y=lat)) +
  geom_hex()
```

## Aesthetics

Now let's look at how we can use `aes()` to make our visualisations more informative and engaging.

`sleep` has two groups, so let's plot a boxplot of `extra` with the two groups separated by colour.
```{r}
sleep %>% 
  ggplot(aes(x=group,y=extra,fill=group)) +
  geom_boxplot()
```

We could also use colour to differentiate between individuals in an interaction plot. Try it with and without colour.
```{r}
sleep %>% 
  ggplot(aes(x=as.numeric(group),y=extra)) +
  geom_path()

sleep %>% 
  ggplot(aes(x=as.numeric(group),y=extra,colour=ID)) +
  geom_path()
```

We can see that actually having colour specified as a distinct aesthetic separates out each of the IDs into pairs of `extra` values rather than treating them as points that all must be connected to each other. Moreover, we don't *need* to specify what colours to use (although we could).

## Axes

We can add layers to change the axes of the plot, add and change the spacing of the ticks, and label things.
```{r}
quakes %>% 
  ggplot(aes(x=as.factor(mag),y=stations)) +
  geom_boxplot() +
  scale_y_continuous(name = "number of stations reporting",
                     breaks = seq(from=0, to=100, by=50),
                     minor_breaks = seq(from=0, to=150, by=10),
                     limits = c(0,150),
                     position = "right") +
  xlab("magnitude of the quake") +
  ggtitle("Stations by magnitude")
```

What else would you like to do with this graph?
```{r}
# ?
```

## Themes

What if you don't like having a grey background or you're going to use the plot on a slide with a black background and you want it to look slick?

Try out different themes! (If we put `+ NULL` at the end, we can comment out any line of the graph without having to worry what comes next)
```{r}
quakes %>% 
  ggplot(aes(x=as.factor(mag),y=stations)) +
  geom_boxplot() +
  scale_y_continuous(name = "number of stations reporting",
                     breaks = seq(from=0, to=100, by=50),
                     minor_breaks = seq(from=0, to=150, by=10),
                     limits = c(0,150),
                     position = "right") +
  xlab("magnitude of the quake") +
  ggtitle("Stations by magnitude") +
  #theme_bw() +
  #theme_classic() +
  #theme_dark() +
  #theme_light() +
  #theme_minimal() +
  #theme_test() +
  #theme_void() +
  theme() +
  NULL
```

### Legends

## Extras

### Annotations

### Error bars 

## Beyond `tidyverse`

### Beeswarm vs Violin

### `plotly`

### Pirate plots

# Exploration

Plot boxplots and violin plots for the ratings. Subset by participant.
```{r}
data %>%
  filter(region == 1) %>%
  ggplot(aes(x=gram, y=rating, fill=freq)) +
  geom_boxplot(position = position_dodge(.9)) +
  #geom_violin(alpha=.5) +
  facet_wrap(~subj)
```

Group by region, word, frequency, and grammaticality. Summarise mean and standard error.
```{r}
data %>%
  group_by(region, word, freq, gram) %>%
  summarise(meanRT = mean(rt),
            seRT = sd(rt)/sqrt(n())) %>%
  ggplot(aes(x=region,y=meanRT,colour=gram)) +
    geom_point() +
    geom_path(aes(lty=freq)) +
    geom_errorbar(aes(ymin=meanRT-seRT, ymax=meanRT+seRT),width=.1) +
  scale_x_continuous(breaks=c(1:5),labels = c("the","old","VERB","the","boat")) +
  ylab("reading time (miliseconds)")
```

## Why? 

Well, check out the [Datasaurus Dozen](https://www.autodeskresearch.com/publications/samestats), which all have the same x/y means and standard deviations:
![](../images/datasaurus.gif)

## Try it out

> Dataset `iris`:

The function `ggplot` layers different geometries and aesthetics to build up a plot:
```{r}
iris %>%
  mutate(Sepal.Width = Sepal.Width+rnorm(length(Sepal.Width),0,.1))%>%
  ggplot(aes(x=Species,y=Sepal.Width,fill=Species)) +
  geom_violin(lty=0,alpha=.5)+
  geom_boxplot(alpha=0.5,lwd=.5) +
  geom_quasirandom(dodge.width=1, alpha=.5)
```

In what ways might we change this plot?
```{r}
iris %>%
  mutate(
    Sepal.Width = Sepal.Width + 
      rnorm(
        length(Sepal.Width) , 0 , .1
        )
    ) %>%
  ggplot(aes(x=Species,y=Sepal.Width)) +
  geom_boxplot() +
  geom_quasirandom(aes(pch=Species), alpha=.5)
  #ggplot(aes(x=Species,y=Sepal.Width,fill=Species)) +
  #geom_violin(lty=0,alpha=.5)+
  #geom_boxplot(alpha=0.5,lwd=.5) +
  #geom_quasirandom(dodge.width=1, alpha=.5)
```


Going back to `quakes`, let's pipe our table into a ggplot (and fill in missing values):
```{r}
quakes %>%
  group_by(mag) %>%
  summarise(n=n(),
            sta=mean(stations),
            staSD=sd(stations),
            staSE=staSD/sqrt(n),
            dep=mean(depth),
            depSD=sd(depth),
            depSE=depSD/sqrt(n)) %>%
  ggplot(aes(x=mag)) +
  geom_point(aes(y=sta),colour="red")+
  geom_path(aes(y=sta),colour="red")+
  geom_ribbon(aes(ymin=sta-staSD,ymax=sta+staSD),fill="red",alpha=.2) +
  geom_ribbon(aes(ymin=sta-staSE,ymax=sta+staSE),fill="red",alpha=.5) +
  geom_point(aes(y=dep),colour="blue")+
  geom_path(aes(y=dep),colour="blue")+
  geom_ribbon(aes(ymin=dep-depSD,ymax=dep+depSD),fill="blue",alpha=.2) +
  geom_ribbon(aes(ymin=dep-depSE,ymax=dep+depSE),fill="blue",alpha=.5) +
  theme_bw() + ylab("depth OR number of stations reporting")
```

Inheritance:
```{r}
ggplot(data=quakes, aes(x=long)) +
  geom_point(aes(y=lat,colour=stations)) #+
  #geom_path()
```
